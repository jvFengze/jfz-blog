---
title: 常见知识点整理|JS
index_img: ./img/jsAudition.jpg
date: 2023-3-30 16:24
categories: 面试
---

# 1.什么是原型/原型链？

原型的本质是一个**对象**

我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性对应着一个对象，这个对象就是我们所谓的原型对象，即**显式原型**。

原型对象就相当于一个公共的区域，**所有同一个类的实例都可以访问到这个原型对象**，所以我们通过构造函数**创建的实例对象**都会从这个函数的原型对象上继承上面具有的属性

> 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype属性(指向原型对象)。默认去情况下，所有的原型对象自动获得一个名为constructor的属性，指回与之关联的构造函数。Person.prototype.constructor指向Person。然后，因构造函数而异，可能会给原型对象中添加其他属性和方法。

当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，我们可以通过`__proto__`（隐式原型）来访问该属性。

访问一个对象的属性时，先在自身属性中查找，找到返回， 如果没有，再沿着`__proto__`这条链向上查找，找到返回，如果最终没找到，返回undefined，这就是**原型链**，又称隐式原型链，它的作用就是查找对象的属性(方法)。

# 2.什么闭包

定义：闭包是指**引用了其他函数作用域中变量的函数**，通常是在嵌套函数中实现的。

> 从技术角度上所有 js 函数都是闭包。
>
> 从实践角度来看，满足以下俩个条件的函数算闭包
>
> 1. 即使创建它的上下文被销毁了，它依然存在。（比如从父函数中返回）
> 2. 在代码中引用了自由变量（在函数中使用的既不是函数参数也不是函数局部变量的变量称作自由变量）

**它最大用处有两个**：一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中

**闭包的优点：**

1. 可以减少全局变量的定义，避免全局变量的污染
2. 能够读取函数内部的变量
3. 在内存中维护一个变量，可以用做缓存

**缺点：**

1. 造成内存泄露

   闭包会使函数中的变量一直保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。

   解决方法——使用完变量后，手动将它赋值为null；

2. 闭包可能在父函数外部，改变父函数内部变量的值。

3. 造成性能损失

   由于闭包涉及跨作用域的访问，所以会导致性能损失。

   解决方法——通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响

**生命周期：**

1. 产生：在嵌套内部函数定义执行完时就产生了(不是在调用)
2. 死亡：在嵌套的内部函数成为垃圾对象时就死亡了

**应用**

- 柯里化函数
- 例如计数器、延迟调用、回调函数等

# 3.this指向

解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的上下文对象，根据函数的调用方式的不同，this会指向不同的对象

- 全局的this非严格模式指向window对象，严格模式指向 undefined
- 以函数的形式调用时，this永远都是window
- 以方法的形式调用时，this就是调用方法的那个对象
- 当以构造函数的形式调用时，this就是新创建的那个对象
- 箭头函数中的this指向它的父级作用域，它自身不存在 this

> apply、call、bind 可以变更 this 指向为第一个传参

# 4.事件循环

见![js事件循环](https://koi85.club/2023/02/20/eventLoop/)

# 5.js中数据在栈和堆中的存储方式

- 基本数据类型大小固定且操作简单，所以放入栈中存储
- 引用数据类型大小不确定，所以将它们放入堆内存中，让它们在申请内存的时候自己确定大小

这样分开存储可以使内存占用最小。栈的效率高于堆

栈内存中变量在执行环境结束后会立即进行垃圾回收，而堆内存中需要变量的所有引用都结束才会被回收

# v8垃圾回收

